<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>TI-84+CE utils</title>
    <script src="https://cdn.jsdelivr.net/npm/ticalc-usb@latest/dist/index.js"></script>
</head>

<body>
    <h1>TI-84+CE utils</h1>
    <h2>Python model supported aswell!</h2>
    <div id="flow">
        <p hidden><b>Supported devices:</b> <span id="supported"></span></p>
        <div class="buttons">
            <button id="connect">Connect Calculator</button>
            <select id="presetSelect" disabled>
                <option value="">-- Select Preset --</option>
            </select>
            <button id="start" disabled>Send Files</button>
            <div id="progressContainer" style="display:none; margin-top:1em;">
                <label hidden for="progressBar">Sending progress:</label>
                <progress id="progressBar" max="100" value="0" style="width: 100%;"></progress>
                <div id="progressText" style="text-align:center;"></div>
            </div>

        </div>
    </div>

    <div id="incompatible" style="display:none;">
        <p>Your browser does not support WebUSB.</p>
    </div>

    <div id="popup" class="popup"
        style="display:none; position: fixed; top: 30%; left: 50%; transform: translateX(-50%); background: #eee; padding: 1em; border: 1px solid #aaa;">
        <h2></h2>
        <p></p>
        <div class="buttons"></div>
    </div>

    <script>
        // Catch any synchronous error (runtime exceptions)
        window.onerror = function (message, source, lineno, colno, err) {
            alert(`Error: ${message}\nSource: ${source}\nLine: ${lineno}, Column: ${colno}\nDetails: ${err ? err.stack : 'N/A'}`);
            // Return false to let the error propagate to the console as well
            return false;
        };

        // Catch unhandled rejected promises
        window.addEventListener('unhandledrejection', function (event) {
            alert(`Unhandled promise rejection: ${event.reason ? event.reason.stack || event.reason : 'Unknown error'}`);
        });

        const { ticalc, tifiles } = window["ticalc-usb"];
        let calculator = null;
        let preset = null;
        /*const apps = [
            {
                id: "geometrydash",
                directory: "geometrydash"

            },
            {
                id: "contaigon",
                directory: "contaigon"

            }
        ]*/
        const presets = [
            {
                name: "Games",
                apps: [
                    "geometrydash",
                    "contaigon",
                    "chess"
                ]/*,
                files: [
                    "./dinorunce.8xp",
                    "./atomas.8xp",
                    "./minecraft2dce.8xp",
                    "./minesweeper.8xp"
                ]*/,
                info: "Launch via Cesium! (in the INSTALL FIRST package)"
            },
            {
                name: "Math & Educational",
                /*files: [
                    "./calculus.8xp",
                    "./calc2.8xp",
                    "./geometryformulas.8xp",
                    "./factoring.8xp"
                ],*/
                apps:[
                "calculus",
                "factoring"
                ],
                info: "Launch via Cesium! (in the INSTALL FIRST package)"
            },
            {
                name: "INSTALL FIRST",
                files: [
                    "./cesium.8xp",
                    "./artifice.8xp",
                    "./clibs.8xg"
                ],
                info: "Open programs, open *A, then select Cesium. Now exit ArTIfiCE and open Cesium in the apps menu."
            }
        ];


        window.addEventListener('load', async () => {
            if (ticalc.browserSupported()) {
                showSupportedDevices();
                attachConnectionListeners();
                attachClickListeners();
                populatePresets();

                try {
                    await ticalc.init({ supportLevel: 'none' });
                } catch (e) {
                    handleUnsupported(e);
                }
                updateButtons();
                document.querySelector('#flow').style.display = 'block';
                document.querySelector('#incompatible').style.display = 'none';
            } else {
                document.querySelector('#flow').style.display = 'none';
                document.querySelector('#incompatible').style.display = 'block';
            }
        });

        function showSupportedDevices() {
            const calcNames = ticalc.models()
                .filter(c => c.status === 'supported' || c.status === 'beta')
                .map(c => c.status === 'beta' ? c.name + ' (beta)' : c.name)
                .join(', ');
            document.querySelector('#supported').innerText = calcNames || "None";
        }

        function updateButtons() {
            document.querySelector('#connect').disabled = !!calculator;
            document.querySelector('#presetSelect').disabled = !calculator;
            document.querySelector('#start').disabled = !(calculator && preset);
        }

        function attachConnectionListeners() {
            ticalc.addEventListener('disconnect', calc => {
                if (calc !== calculator) return;
                calculator = null;
                alert("Disconnected", "Calculator disconnected.");
                updateButtons();
            });

            ticalc.addEventListener('connect', async calc => {
                if (calc.status === 'experimental') {
                    confirm('Be careful!', `Your device (${calc.name}) only has ${calc.status} support. Continue?`)
                        .then(() => connect(calc))
                        .catch(() => { });
                } else {
                    await connect(calc);
                }
            });
        }

        async function connect(calc) {
            try {
                if (await calc.isReady()) {
                    calculator = calc;
                    alert('Connected', `Connected to ${calculator.name}.`);
                    updateButtons();
                } else {
                    alert('Error', 'The connected device is not responding.');
                }
            } catch (e) {
                alert('Connection Error', 'Failed to connect to device.');
                console.error(e);
            }
        }

        function attachClickListeners() {
            document.querySelector('#connect').addEventListener('click', async () => {
                try {
                    await ticalc.choose();
                } catch (e) {
                    handleUnsupported(e);
                }
            });

            const presetSelect = document.querySelector('#presetSelect');
            presetSelect.addEventListener('change', e => {
                const idx = e.target.value;
                if (idx !== "") {
                    preset = presets[idx];
                    //alert("Preset Selected", `You chose ${preset.name}.`);
                } else {
                    preset = null;
                }
                updateButtons();
            });

            document.querySelector('#start').addEventListener('click', async () => {
                if (!calculator || !preset) return;

                let filesToSend = [];

                // Add files from preset.files array
                if (preset.files) {
                    filesToSend.push(...preset.files);
                }

                // Add files from apps directories if preset.apps is defined
                if (preset.apps) {
                    for (const appId of preset.apps) {

                        try {
                            // Fetch the JSON file listing all files inside app directory
                            const listResponse = await fetch(`./apps/${appId}/files.json`);
                            if (!listResponse.ok) {
                                alert('Error', `Failed to load file list for app: ${appId}`);
                                return;
                            }
                            const fileList = await listResponse.json(); // Expecting an array of filenames

                            // Append all files with full directory paths
                            filesToSend.push(...fileList.map(name => `./apps/${appId}/${name}`));
                        } catch (e) {
                            alert('Error', `Failed to fetch file list for app '${appId}':\n${e.message}`);
                            return;
                        }
                    }
                }

                // Sequentially fetch, parse, validate, check memory, and send each file
                const progressContainer = document.getElementById('progressContainer');
                const progressBar = document.getElementById('progressBar');
                const progressText = document.getElementById('progressText');

                progressContainer.style.display = 'block';  // Show progress UI
                progressBar.value = 0;
                progressText.textContent = '0%';

                // Calculate total files count for progress
                const totalFiles = filesToSend.length;

                for (let i = 0; i < totalFiles; i++) {
                    const url = filesToSend[i];
                    try {
                        const response = await fetch(url);
                        if (!response.ok) {
                            alert('Download Error', `Failed to download file: ${url}`);
                            return;
                        }
                        const buffer = await response.arrayBuffer();
                        const file = tifiles.parseFile(new Uint8Array(buffer));

                        if (!tifiles.isValid(file)) {
                            alert('Invalid File', `Invalid calculator file: ${url}`);
                            return;
                        }
                        if (!calculator.canReceive(file)) {
                            alert('File Error', `File not valid for ${calculator.name}: ${url}`);
                            return;
                        }

                        const details = await calculator.getStorageDetails(file);
                        if (!details.fits) {
                            alert('Memory Error', `Not enough memory on calculator for file: ${url}`);
                            return;
                        }

                        await calculator.sendFile(file);
                        console.log(`Sent: ${url}`);

                        // Update progress
                        const percent = Math.round(((i + 1) / totalFiles) * 100);
                        progressBar.value = percent;
                        progressText.textContent = `${percent}% (${i + 1} of ${totalFiles}) sent. (${url})`;

                    } catch (error) {
                        alert('Send Error', `Failed to send file: ${url}\n${error.message}`);
                        return;
                    }
                }

                // Hide progress UI and disable button after all files sent
                progressContainer.style.display = 'none';
                document.querySelector('#start').disabled = true;
                alert('Next Steps', preset.info);

            });

        }

        function populatePresets() {
            const select = document.querySelector('#presetSelect');
            presets.forEach((p, i) => {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = p.name;
                select.appendChild(option);
            });
        }

        function handleUnsupported(error) {
            console.error(error);
            alert('Unsupported', error.message || 'Your calculator may not be supported yet.');
        }

        /* Popup system */
        function setPopup(title, body) {
            const popup = document.getElementById('popup');
            popup.querySelector('h2').innerText = title;
            popup.querySelector('p').innerText = body;
            popup.querySelector('.buttons').innerHTML = '';
            popup.style.display = 'block';
            return popup;
        }

        function popupButton(clss, text, fn) {
            const button = document.createElement('button');
            button.classList.add(clss);
            button.innerText = text;
            button.onclick = fn;
            return button;
        }

        async function alert(title, body) {
            return new Promise(resolve => {
                const popup = setPopup(title, body);
                const button = popupButton('yes', 'Okay', () => {
                    popup.style.display = 'none';
                    resolve();
                });
                popup.querySelector('.buttons').appendChild(button);
            });
        }

        async function confirm(title, body) {
            return new Promise((resolve, reject) => {
                const popup = setPopup(title, body);
                const yesButton = popupButton('yes', 'Okay', () => {
                    popup.style.display = 'none';
                    resolve();
                });
                const noButton = popupButton('no', 'Cancel', () => {
                    popup.style.display = 'none';
                    reject();
                });
                popup.querySelector('.buttons').appendChild(yesButton);
                popup.querySelector('.buttons').appendChild(noButton);
            });
        }
    </script>
</body>

</html>